<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasas de Cambio VES/USD</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- TradingView Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

    <!-- Alpine.js CDN -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        * {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        .card {
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen py-6" x-data="chartApp()">
        <div class="max-w-7xl mx-auto px-4 sm:px-6">

            <!-- Header -->
            <div class="mb-6">
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">Tasas de Cambio VES/USD</h1>
                        <p class="text-sm text-gray-500 mt-1">Monitoreo en tiempo real</p>
                    </div>
                    <div class="text-right text-xs text-gray-500" x-show="startDate && endDate">
                        <div><span x-text="startDate"></span> — <span x-text="endDate"></span></div>
                        <div class="mt-0.5" x-show="bcvDataPoints || binanceDataPoints">
                            <span x-text="bcvDataPoints"></span> BCV · <span x-text="binanceDataPoints"></span> Binance
                        </div>
                    </div>
                </div>
            </div>

            <!-- Metrics Grid -->
            <div x-show="stats.bcv && stats.binance" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">

                <!-- BCV Rate -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 card">
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xs font-semibold text-gray-500 uppercase tracking-wide">BCV Oficial</span>
                        <div class="w-2 h-2 rounded-full bg-blue-500"></div>
                    </div>
                    <div class="text-3xl font-bold text-gray-900 mb-1" x-text="formatRate(stats.bcv?.current)"></div>
                    <div class="text-xs text-gray-500">Bs/USD</div>
                </div>

                <!-- Binance Rate -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 card">
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xs font-semibold text-gray-500 uppercase tracking-wide">Binance P2P</span>
                        <div class="w-2 h-2 rounded-full bg-orange-500"></div>
                    </div>
                    <div class="text-3xl font-bold text-gray-900 mb-1" x-text="formatRate(stats.binance?.current)"></div>
                    <div class="text-xs text-gray-500">Bs/USD</div>
                </div>

                <!-- Calculator Quick -->
                <div class="bg-gradient-to-br from-emerald-600 to-teal-600 rounded-lg shadow-sm p-4 card text-white">
                    <div class="text-xs font-semibold uppercase tracking-wide mb-3 opacity-90">Calculadora</div>
                    <input
                        type="number"
                        x-model="usdAmount"
                        @input="calculateConversion()"
                        placeholder="100"
                        class="w-full px-3 py-2 bg-white/20 border border-white/30 rounded text-sm font-semibold text-white placeholder-white/60 focus:outline-none focus:ring-2 focus:ring-white/50 mb-2"
                    >
                    <div class="text-xl font-bold" x-text="formatUsd(usdBinance)"></div>
                    <div class="text-xs opacity-75">en Binance</div>
                </div>

            </div>

            <!-- Spread Stats -->
            <div x-show="stats.spreadStats" class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                <div class="mb-6">
                    <h3 class="text-sm font-bold text-gray-900">Indicador de Spread</h3>
                </div>

                <!-- Visual indicator bar with breakpoints -->
                <div class="relative px-2">
                    <!-- Current value marker (above bar) -->
                    <div class="relative h-8 mb-0.5">
                        <div
                            class="absolute bottom-0 transform -translate-x-1/2 z-30"
                            :style="'left: ' + Math.min(100, Math.max(0, ((stats.spreadPercent - (stats.spreadStats?.min || 0)) / ((stats.spreadStats?.max || 100) - (stats.spreadStats?.min || 0))) * 100)) + '%'"
                        >
                            <div class="text-center">
                                <div class="text-xs font-bold text-indigo-700 leading-none mb-0.5" x-text="formatPercentage(stats.spreadPercent)"></div>
                                <div
                                    class="text-[8px] font-bold uppercase px-1 py-px rounded-full inline-block leading-none"
                                    :class="{
                                        'bg-green-100 text-green-700': getSpreadIndicator() === 'high',
                                        'bg-amber-100 text-amber-700': getSpreadIndicator() === 'medium',
                                        'bg-red-100 text-red-700': getSpreadIndicator() === 'low'
                                    }"
                                    x-text="getSpreadIndicator() === 'high' ? 'EXCELENTE' : getSpreadIndicator() === 'medium' ? 'BUENO' : 'BAJO'"
                                ></div>
                            </div>
                            <div class="w-px h-3 bg-indigo-600 mx-auto mt-0.5"></div>
                        </div>
                    </div>

                    <!-- Gradient bar -->
                    <div class="relative h-3 bg-gradient-to-r from-red-500 via-amber-500 via-lime-500 to-green-500 rounded-full shadow-sm">
                        <!-- Current position indicator -->
                        <div
                            class="absolute transform -translate-x-1/2 -translate-y-[3px] z-20"
                            :style="'left: ' + Math.min(100, Math.max(0, ((stats.spreadPercent - (stats.spreadStats?.min || 0)) / ((stats.spreadStats?.max || 100) - (stats.spreadStats?.min || 0))) * 100)) + '%'"
                        >
                            <!-- Outer glow ring -->
                            <div class="absolute inset-0 w-5 h-5 bg-indigo-400 rounded-full opacity-30 animate-ping"></div>
                            <!-- Main indicator -->
                            <div class="relative w-5 h-5 bg-gradient-to-br from-indigo-500 to-indigo-700 rounded-full shadow-lg border-2 border-white"></div>
                        </div>
                    </div>

                    <!-- Breakpoint markers (below bar) -->
                    <div class="relative h-10 mt-3">
                        <!-- MIN marker -->
                        <div class="absolute transform -translate-x-1/2" style="left: 0%">
                            <div class="w-px h-4 bg-red-400 mx-auto"></div>
                            <div class="text-center mt-1 min-w-max">
                                <div class="text-xs font-bold text-red-600" x-text="formatPercentage(stats.spreadStats?.min)"></div>
                                <div class="text-[10px] font-medium text-gray-400 uppercase">Bajo</div>
                            </div>
                        </div>

                        <!-- AVG marker -->
                        <div
                            class="absolute transform -translate-x-1/2"
                            :style="'left: ' + ((stats.spreadStats?.avg - stats.spreadStats?.min) / (stats.spreadStats?.max - stats.spreadStats?.min) * 100) + '%'"
                        >
                            <div class="w-px h-4 bg-amber-400 mx-auto"></div>
                            <div class="text-center mt-1 min-w-max">
                                <div class="text-xs font-bold text-amber-600" x-text="formatPercentage(stats.spreadStats?.avg)"></div>
                                <div class="text-[10px] font-medium text-gray-400 uppercase">Bueno</div>
                            </div>
                        </div>

                        <!-- P75 marker -->
                        <div
                            class="absolute transform -translate-x-1/2"
                            :style="'left: ' + ((stats.spreadStats?.p75 - stats.spreadStats?.min) / (stats.spreadStats?.max - stats.spreadStats?.min) * 100) + '%'"
                        >
                            <div class="w-px h-4 bg-lime-400 mx-auto"></div>
                            <div class="text-center mt-1 min-w-max">
                                <div class="text-xs font-bold text-lime-600" x-text="formatPercentage(stats.spreadStats?.p75)"></div>
                                <div class="text-[10px] font-medium text-gray-400 uppercase">Excelente</div>
                            </div>
                        </div>

                        <!-- MAX marker -->
                        <div class="absolute transform -translate-x-1/2" style="left: 100%">
                            <div class="w-px h-4 bg-green-400 mx-auto"></div>
                            <div class="text-center mt-1 min-w-max">
                                <div class="text-xs font-bold text-green-600" x-text="formatPercentage(stats.spreadStats?.max)"></div>
                                <div class="text-[10px] font-medium text-gray-400 uppercase">Máximo</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Chart -->
            <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                <div class="px-5 py-4 border-b border-gray-200">
                    <div class="flex items-center justify-between">
                        <h2 class="text-base font-bold text-gray-900">Evolución de Tasas</h2>
                        <div class="flex items-center gap-4 text-xs font-medium">
                            <div class="flex items-center gap-1.5">
                                <div class="w-3 h-0.5 bg-blue-600 rounded-full"></div>
                                <span class="text-gray-600">BCV</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-3 h-0.5 bg-orange-600 rounded-full"></div>
                                <span class="text-gray-600">Binance</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-3 h-2 bg-indigo-600 rounded opacity-60"></div>
                                <span class="text-gray-600">Spread</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="p-5">
                    <div x-show="loading" class="flex justify-center items-center" style="height: 450px;">
                        <div class="text-center">
                            <div class="w-12 h-12 border-4 border-gray-200 border-t-indigo-600 rounded-full animate-spin mx-auto mb-3"></div>
                            <p class="text-sm text-gray-500">Cargando datos...</p>
                        </div>
                    </div>

                    <div x-show="!loading && error" class="flex justify-center items-center" style="height: 450px;">
                        <div class="text-center">
                            <svg class="w-16 h-16 mx-auto mb-3 text-red-500 opacity-30" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <p class="text-base font-semibold text-gray-900" x-text="error"></p>
                        </div>
                    </div>

                    <div x-show="!loading && !error">
                        <div id="ratesChart" class="w-full" style="height: 450px;"></div>
                        <p class="text-center text-xs text-gray-400 mt-3">
                            Rueda del mouse para zoom • Arrastra para navegar • Doble clic para resetear
                        </p>
                    </div>
                </div>
            </div>

            <!-- Spread Analysis Chart -->
            <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                <div class="px-5 py-4 border-b border-gray-200">
                    <div class="flex items-center justify-between">
                        <h2 class="text-base font-bold text-gray-900">Análisis de Spread</h2>
                        <div class="flex items-center gap-3 text-xs font-medium">
                            <div class="flex items-center gap-1.5">
                                <div class="w-2 h-2 rounded-full bg-red-600"></div>
                                <span class="text-gray-600">Bajo</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-2 h-2 rounded-full bg-amber-500"></div>
                                <span class="text-gray-600">Medio</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-2 h-2 rounded-full bg-green-600"></div>
                                <span class="text-gray-600">Alto</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="p-5">
                    <div x-show="loading" class="flex justify-center items-center" style="height: 300px;">
                        <div class="w-10 h-10 border-4 border-gray-200 border-t-indigo-600 rounded-full animate-spin"></div>
                    </div>

                    <div x-show="!loading && !error">
                        <div id="spreadPercentChart" class="w-full" style="height: 300px;"></div>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        function chartApp() {
            return {
                days: 30,
                endDate: new Date().toISOString().split('T')[0],
                startDate: '',
                loading: false,
                error: null,
                chart: null,
                bcvSeries: null,
                binanceSeries: null,
                spreadSeries: null,
                spreadChart: null,
                spreadChartSeries: null,
                stats: {
                    bcv: null,
                    binance: null,
                    spread: null,
                    spreadPercent: null,
                    spreadStats: null
                },
                bcvDataPoints: 0,
                binanceDataPoints: 0,
                usdAmount: 100,
                usdBinance: 0,
                usdDifference: 0,

                init() {
                    this.fetchData();
                },

                calculateConversion() {
                    if (!this.stats.bcv || !this.stats.binance || !this.usdAmount) {
                        this.usdBinance = 0;
                        this.usdDifference = 0;
                        return;
                    }

                    const usdBcv = parseFloat(this.usdAmount) || 0;
                    // USD BCV → Bs (usando tasa BCV)
                    const bsTotal = usdBcv * this.stats.bcv.current;
                    // Bs → USD Binance (usando tasa Binance)
                    this.usdBinance = bsTotal / this.stats.binance.current;
                    // Diferencia en USD
                    this.usdDifference = this.usdBinance - usdBcv;
                },

                async fetchData() {
                    this.loading = true;
                    this.error = null;

                    try {
                        const url = `/api/exchange-rates/bcv/?days=${this.days}&end_date=${this.endDate}`;
                        const response = await fetch(url);

                        if (!response.ok) {
                            throw new Error('Error al cargar los datos');
                        }

                        const data = await response.json();

                        this.startDate = data.start_date;
                        this.bcvDataPoints = data.bcv.length;
                        this.binanceDataPoints = data.binance_sell.length;

                        if (data.bcv.length === 0 && data.binance_sell.length === 0) {
                            this.error = 'No hay datos disponibles para este período';
                            this.loading = false;
                            return;
                        }


                        this.calculateStats(data.bcv, data.binance_sell);
                        this.calculateConversion();
                        this.renderChart(data.bcv, data.binance_sell);

                    } catch (err) {
                        this.error = err.message;
                        console.error('Error:', err);
                    } finally {
                        this.loading = false;
                    }
                },

                calculateStats(bcvRates, binanceRates) {
                    // Stats BCV
                    if (bcvRates.length > 0) {
                        const bcvValues = bcvRates.map(r => r.rate);
                        this.stats.bcv = {
                            current: bcvValues[bcvValues.length - 1],
                            max: Math.max(...bcvValues),
                            min: Math.min(...bcvValues),
                            change: bcvValues[bcvValues.length - 1] - bcvValues[0]
                        };
                    }

                    // Stats Binance
                    if (binanceRates.length > 0) {
                        const binanceValues = binanceRates.map(r => r.rate);
                        this.stats.binance = {
                            current: binanceValues[binanceValues.length - 1],
                            max: Math.max(...binanceValues),
                            min: Math.min(...binanceValues),
                            change: binanceValues[binanceValues.length - 1] - binanceValues[0]
                        };
                    }

                    // Calcular spread actual
                    if (this.stats.bcv && this.stats.binance) {
                        this.stats.spread = this.stats.binance.current - this.stats.bcv.current;
                        this.stats.spreadPercent = (this.stats.spread / this.stats.binance.current) * 100;
                    }

                    // Calcular estadísticas del spread histórico
                    if (bcvRates.length > 0 && binanceRates.length > 0) {
                        const bcvMap = new Map();
                        bcvRates.forEach(r => {
                            bcvMap.set(r.date, parseFloat(r.rate));
                        });

                        // Calcular spreads para todos los puntos de Binance
                        const spreadPercents = [];
                        const spreadBs = [];

                        binanceRates.forEach(r => {
                            const date = r.timestamp.split('T')[0];
                            const bcvRate = bcvMap.get(date);
                            const binanceRate = parseFloat(r.rate);

                            if (bcvRate && !isNaN(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                                const spreadPct = ((binanceRate - bcvRate) / binanceRate) * 100;
                                const spreadB = binanceRate - bcvRate;

                                if (!isNaN(spreadPct) && isFinite(spreadPct)) {
                                    spreadPercents.push(spreadPct);
                                    spreadBs.push(spreadB);
                                }
                            }
                        });

                        if (spreadPercents.length > 0) {
                            // Ordenar para calcular percentiles
                            const sortedPercents = [...spreadPercents].sort((a, b) => a - b);
                            const sortedBs = [...spreadBs].sort((a, b) => a - b);

                            const avg = spreadPercents.reduce((a, b) => a + b, 0) / spreadPercents.length;
                            const avgBs = spreadBs.reduce((a, b) => a + b, 0) / spreadBs.length;

                            // Calcular desviación estándar
                            const variance = spreadPercents.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / spreadPercents.length;
                            const stdDev = Math.sqrt(variance);

                            // Calcular percentiles
                            const p25 = sortedPercents[Math.floor(sortedPercents.length * 0.25)];
                            const p50 = sortedPercents[Math.floor(sortedPercents.length * 0.50)];
                            const p75 = sortedPercents[Math.floor(sortedPercents.length * 0.75)];

                            this.stats.spreadStats = {
                                avg: avg,
                                avgBs: avgBs,
                                max: Math.max(...spreadPercents),
                                min: Math.min(...spreadPercents),
                                maxBs: Math.max(...spreadBs),
                                minBs: Math.min(...spreadBs),
                                stdDev: stdDev,
                                p25: p25,
                                p50: p50,
                                p75: p75,
                                spreadPercents: spreadPercents,
                                spreadBs: spreadBs
                            };
                        }
                    }
                },

                fillBcvGaps(bcvRates, binanceRates) {
                    if (bcvRates.length === 0) return [];

                    // Si no hay datos de Binance, devolver BCV como está (con timestamps de medianoche)
                    if (binanceRates.length === 0) {
                        return bcvRates.map(r => ({
                            timestamp: r.date + 'T00:00:00Z',
                            rate: r.rate
                        }));
                    }

                    // Crear mapa de fechas BCV (solo fecha, sin hora)
                    const bcvMap = new Map();
                    bcvRates.forEach(r => {
                        const rate = parseFloat(r.rate);
                        if (!isNaN(rate) && isFinite(rate)) {
                            bcvMap.set(r.date, rate);
                        }
                    });

                    // Obtener todos los timestamps únicos de Binance
                    const binanceTimestamps = binanceRates.map(r => ({
                        timestamp: r.timestamp,
                        date: r.timestamp.split('T')[0]
                    }));

                    // Para cada timestamp de Binance, asignar el valor de BCV de ese día
                    const filled = [];
                    let lastKnownValue = null;

                    binanceTimestamps.forEach(item => {
                        const bcvValue = bcvMap.get(item.date);

                        // Si hay valor para ese día, usarlo; si no, usar el último conocido
                        if (bcvValue !== undefined) {
                            lastKnownValue = bcvValue;
                        }

                        if (lastKnownValue !== null) {
                            filled.push({
                                timestamp: item.timestamp,
                                rate: lastKnownValue
                            });
                        }
                    });

                    return filled;
                },

                renderChart(bcvRates, binanceRates) {
                    const container = document.getElementById('ratesChart');

                    // Verificar que la biblioteca esté disponible
                    if (typeof LightweightCharts === 'undefined') {
                        console.error('LightweightCharts no está disponible');
                        this.error = 'Error al cargar la biblioteca de gráficos';
                        return;
                    }

                    // Rellenar huecos en BCV sincronizando con timestamps de Binance
                    const bcvFilled = this.fillBcvGaps(bcvRates, binanceRates);

                    // Remover chart anterior si existe
                    if (this.chart) {
                        this.chart.remove();
                        this.chart = null;
                    }

                    // Crear nuevo chart con dos escalas de precio
                    this.chart = LightweightCharts.createChart(container, {
                        width: container.clientWidth,
                        height: 350,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333',
                        },
                        grid: {
                            vertLines: { color: '#f0f0f0' },
                            horzLines: { color: '#f0f0f0' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#cccccc',
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.2,
                            },
                        },
                        leftPriceScale: {
                            visible: true,
                            borderColor: '#9333ea',
                            scaleMargins: {
                                top: 0.6,
                                bottom: 0.05,
                            },
                        },
                        timeScale: {
                            borderColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                        handleScroll: {
                            mouseWheel: true,
                            pressedMouseMove: true,
                        },
                        handleScale: {
                            axisPressedMouseMove: true,
                            mouseWheel: true,
                            pinch: true,
                        },
                    });

                    // Serie BCV (línea azul)
                    if (bcvFilled.length > 0) {
                        this.bcvSeries = this.chart.addLineSeries({
                            color: '#2563eb',
                            lineWidth: 2,
                            title: 'BCV (Oficial)',
                            priceFormat: {
                                type: 'price',
                                precision: 4,
                                minMove: 0.0001,
                            },
                        });

                        // Convertir datos a formato TradingView usando timestamps Unix
                        const bcvData = bcvFilled
                            .map(r => {
                                const timestamp = new Date(r.timestamp).getTime();
                                return {
                                    time: Math.floor(timestamp / 1000),
                                    value: parseFloat(r.rate)
                                };
                            })
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (bcvData.length > 0 && !bcvData.some(d => d.value === undefined)) {
                            this.bcvSeries.setData(bcvData);
                        }
                    }

                    // Serie Binance (línea naranja)
                    if (binanceRates.length > 0) {
                        this.binanceSeries = this.chart.addLineSeries({
                            color: '#f97316',
                            lineWidth: 2,
                            title: 'Binance P2P (Venta)',
                            priceFormat: {
                                type: 'price',
                                precision: 4,
                                minMove: 0.0001,
                            },
                        });

                        const binanceData = binanceRates
                            .map(r => {
                                const timestamp = new Date(r.timestamp).getTime();
                                return {
                                    time: Math.floor(timestamp / 1000),
                                    value: parseFloat(r.rate)
                                };
                            })
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (binanceData.length > 0 && !binanceData.some(d => d.value === undefined)) {
                            this.binanceSeries.setData(binanceData);
                        }
                    }

                    // Serie de Spread Porcentual (histograma en eje izquierdo)
                    if (bcvFilled.length > 0 && binanceRates.length > 0) {
                        // Crear mapa de timestamps BCV para búsqueda rápida (ahora sincronizado!)
                        const bcvMap = new Map();
                        bcvFilled.forEach(r => {
                            const rate = parseFloat(r.rate);
                            if (!isNaN(rate) && isFinite(rate)) {
                                bcvMap.set(r.timestamp, rate);
                            }
                        });

                        // Calcular spread porcentual para cada punto de Binance
                        const spreadData = [];
                        binanceRates.forEach(r => {
                            const timestamp = r.timestamp;
                            const binanceRate = parseFloat(r.rate);
                            const bcvRate = bcvMap.get(timestamp); // Ahora busca por timestamp exacto!

                            if (bcvRate && !isNaN(binanceRate) && isFinite(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                                const spreadPercent = ((binanceRate - bcvRate) / binanceRate) * 100;
                                const unixTime = Math.floor(new Date(timestamp).getTime() / 1000);

                                // Validar que todos los valores sean válidos
                                if (!isNaN(spreadPercent) && isFinite(spreadPercent) && !isNaN(unixTime)) {
                                    // Color según si el spread es positivo o negativo
                                    const color = spreadPercent >= 0 ? '#9333ea' : '#10b981';

                                    spreadData.push({
                                        time: unixTime,
                                        value: spreadPercent,
                                        color: color
                                    });
                                }
                            }
                        });

                        // Filtrar y ordenar datos del spread
                        const spreadDataFiltered = spreadData
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (spreadDataFiltered.length > 0 && !spreadDataFiltered.some(d => d.value === undefined)) {
                            this.spreadSeries = this.chart.addHistogramSeries({
                                color: '#9333ea',
                                title: 'Spread % (Binance vs BCV)',
                                priceScaleId: 'left',
                                priceFormat: {
                                    type: 'price',
                                    precision: 2,
                                    minMove: 0.01,
                                },
                            });

                            this.spreadSeries.setData(spreadDataFiltered);
                        }
                    }

                    // Configurar vista inicial: mostrar últimos 7 días
                    // Usar setTimeout para asegurar que el chart esté completamente renderizado
                    setTimeout(() => {
                        if (!this.chart) return;

                        // Obtener el rango completo de datos
                        const timeScale = this.chart.timeScale();
                        const logicalRange = timeScale.getVisibleLogicalRange();

                        if (logicalRange) {
                            const totalBars = logicalRange.to;
                            const sevenDaysApprox = 7 * 24 * 4; // 7 días * 24 horas * 4 registros/hora (aprox)
                            const barsToShow = Math.min(sevenDaysApprox, totalBars);

                            // Mostrar solo las últimas barras (últimos 7 días)
                            timeScale.setVisibleLogicalRange({
                                from: totalBars - barsToShow,
                                to: totalBars
                            });
                        }
                    }, 100);

                    // Hacer responsive
                    new ResizeObserver(entries => {
                        if (entries.length === 0 || !this.chart) return;
                        const newWidth = entries[0].contentRect.width;
                        this.chart.applyOptions({ width: newWidth });
                    }).observe(container);

                    // Renderizar gráficos adicionales
                    this.renderSpreadPercentChart(bcvFilled, binanceRates);
                },

                renderSpreadPercentChart(bcvFilled, binanceRates) {
                    const container = document.getElementById('spreadPercentChart');
                    if (!container || typeof LightweightCharts === 'undefined') return;

                    // Remover chart anterior si existe
                    if (this.spreadChart) {
                        this.spreadChart.remove();
                        this.spreadChart = null;
                    }

                    if (bcvFilled.length === 0 || binanceRates.length === 0) return;

                    // Crear mapa de BCV
                    const bcvMap = new Map();
                    bcvFilled.forEach(r => {
                        const rate = parseFloat(r.rate);
                        if (!isNaN(rate) && isFinite(rate)) {
                            bcvMap.set(r.timestamp, rate);
                        }
                    });

                    // Calcular spread porcentual
                    const spreadData = [];
                    binanceRates.forEach(r => {
                        const timestamp = r.timestamp;
                        const binanceRate = parseFloat(r.rate);
                        const bcvRate = bcvMap.get(timestamp);

                        if (bcvRate && !isNaN(binanceRate) && isFinite(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                            const spreadPercent = ((binanceRate - bcvRate) / binanceRate) * 100;
                            const unixTime = Math.floor(new Date(timestamp).getTime() / 1000);

                            if (!isNaN(spreadPercent) && isFinite(spreadPercent) && !isNaN(unixTime)) {
                                // Color basado en umbral P75
                                let color = '#9333ea'; // púrpura por defecto
                                if (this.stats.spreadStats) {
                                    if (spreadPercent >= this.stats.spreadStats.p75) {
                                        color = '#10b981'; // verde = excelente
                                    } else if (spreadPercent >= this.stats.spreadStats.avg) {
                                        color = '#f59e0b'; // amarillo = bueno
                                    } else {
                                        color = '#ef4444'; // rojo = bajo
                                    }
                                }

                                spreadData.push({
                                    time: unixTime,
                                    value: spreadPercent,
                                    color: color
                                });
                            }
                        }
                    });

                    const spreadDataFiltered = spreadData
                        .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                        .sort((a, b) => a.time - b.time);

                    if (spreadDataFiltered.length === 0) return;

                    // Crear chart
                    this.spreadChart = LightweightCharts.createChart(container, {
                        width: container.clientWidth,
                        height: 300,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333',
                        },
                        grid: {
                            vertLines: { color: '#f0f0f0' },
                            horzLines: { color: '#f0f0f0' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#cccccc',
                            autoScale: true,
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.2,
                            },
                        },
                        timeScale: {
                            borderColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                        handleScroll: {
                            mouseWheel: true,
                            pressedMouseMove: true,
                        },
                        handleScale: {
                            axisPressedMouseMove: true,
                            mouseWheel: true,
                            pinch: true,
                        },
                    });

                    // Añadir serie de histograma
                    this.spreadChartSeries = this.spreadChart.addHistogramSeries({
                        color: '#9333ea',
                        priceFormat: {
                            type: 'price',
                            precision: 2,
                            minMove: 0.01,
                        },
                    });

                    this.spreadChartSeries.setData(spreadDataFiltered);

                    // Añadir líneas de referencia (umbrales)
                    if (this.stats.spreadStats) {
                        // Línea promedio (amarilla)
                        const avgLine = this.spreadChart.addLineSeries({
                            color: '#f59e0b',
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Dashed,
                            title: 'Promedio',
                            priceLineVisible: false,
                            lastValueVisible: true,
                        });
                        avgLine.setData(spreadDataFiltered.map(d => ({ time: d.time, value: this.stats.spreadStats.avg })));

                        // Línea P75 (verde)
                        const p75Line = this.spreadChart.addLineSeries({
                            color: '#10b981',
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Dashed,
                            title: 'P75 (Bueno)',
                            priceLineVisible: false,
                            lastValueVisible: true,
                        });
                        p75Line.setData(spreadDataFiltered.map(d => ({ time: d.time, value: this.stats.spreadStats.p75 })));
                    }

                    // Línea invisible en 20% para forzar el eje Y a empezar desde 20%
                    const anchorLine = this.spreadChart.addLineSeries({
                        color: 'transparent',
                        lineWidth: 0,
                        priceLineVisible: false,
                        lastValueVisible: false,
                        crosshairMarkerVisible: false,
                    });
                    anchorLine.setData(spreadDataFiltered.map(d => ({ time: d.time, value: 20 })));

                    // Configurar vista inicial
                    setTimeout(() => {
                        if (!this.spreadChart) return;
                        const timeScale = this.spreadChart.timeScale();
                        const logicalRange = timeScale.getVisibleLogicalRange();

                        if (logicalRange) {
                            const totalBars = logicalRange.to;
                            const sevenDaysApprox = 7 * 24 * 4;
                            const barsToShow = Math.min(sevenDaysApprox, totalBars);

                            timeScale.setVisibleLogicalRange({
                                from: totalBars - barsToShow,
                                to: totalBars
                            });
                        }

                    }, 100);

                    // Hacer responsive
                    new ResizeObserver(entries => {
                        if (entries.length === 0 || !this.spreadChart) return;
                        const newWidth = entries[0].contentRect.width;
                        this.spreadChart.applyOptions({ width: newWidth });
                    }).observe(container);
                },

                formatDate(dateStr) {
                    const date = new Date(dateStr + 'T00:00:00');
                    return date.toLocaleDateString('es-VE', {
                        month: 'short',
                        day: 'numeric'
                    });
                },

                formatRate(rate) {
                    if (!rate) return '-';
                    return rate.toFixed(2) + ' Bs';
                },

                formatChange(change) {
                    if (!change) return '-';
                    const sign = change >= 0 ? '+' : '';
                    return sign + change.toFixed(4) + ' Bs';
                },

                formatPercentage(percent) {
                    if (!percent) return '-';
                    const sign = percent >= 0 ? '+' : '';
                    return sign + percent.toFixed(2) + '%';
                },

                getSpreadIndicator() {
                    if (!this.stats.spreadStats || !this.stats.spreadPercent) return 'low';

                    const current = this.stats.spreadPercent;
                    const avg = this.stats.spreadStats.avg;
                    const p75 = this.stats.spreadStats.p75;

                    if (current >= p75) return 'high';
                    if (current >= avg) return 'medium';
                    return 'low';
                },

                getSpreadLabel() {
                    const indicator = this.getSpreadIndicator();
                    if (indicator === 'high') return 'EXCELENTE';
                    if (indicator === 'medium') return 'BUENO';
                    return 'BAJO';
                },

                formatBsShort(value) {
                    if (!value || isNaN(value)) return '-';
                    return value.toFixed(2) + ' Bs';
                },

                formatUsd(value) {
                    if (!value || isNaN(value)) return '-';
                    const sign = value >= 0 ? '' : '';
                    return sign + value.toFixed(2) + ' USD';
                }
            }
        }
    </script>
</body>
</html>
