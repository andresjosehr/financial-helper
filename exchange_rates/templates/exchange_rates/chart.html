<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasas de Cambio - Gr√°fico</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- TradingView Lightweight Charts (cargar primero, sin defer) -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

    <!-- Alpine.js CDN (defer para cargar despu√©s) -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen py-4 px-4" x-data="chartApp()">
        <div class="max-w-7xl mx-auto">

            <!-- Header -->
            <div class="bg-white rounded-lg shadow-md p-3 mb-3">
                <h1 class="text-2xl font-bold text-gray-800 mb-1">
                    Tasas de Cambio VES/USD
                </h1>
                <p class="text-sm text-gray-600">
                    BCV (oficial) y Binance P2P (venta) - Visualizaci√≥n hist√≥rica
                </p>
            </div>

            <!-- Controls -->
            <div class="bg-white rounded-lg shadow-md p-2 mb-3">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2">

                    <!-- Selector de d√≠as -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Per√≠odo
                        </label>
                        <select
                            x-model="days"
                            @change="fetchData()"
                            class="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                        >
                            <option value="7">√öltima semana (7 d√≠as)</option>
                            <option value="14">√öltimas 2 semanas</option>
                            <option value="30">√öltimo mes (30 d√≠as)</option>
                            <option value="60">√öltimos 2 meses</option>
                            <option value="90">√öltimos 3 meses</option>
                            <option value="180">√öltimos 6 meses</option>
                            <option value="365">√öltimo a√±o</option>
                        </select>
                    </div>

                    <!-- Fecha final -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Fecha final
                        </label>
                        <input
                            type="date"
                            x-model="endDate"
                            @change="fetchData()"
                            class="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                        >
                    </div>

                    <!-- Bot√≥n actualizar -->
                    <div class="flex items-end">
                        <button
                            @click="fetchData()"
                            :disabled="loading"
                            class="w-full px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
                        >
                            <span x-show="!loading">Actualizar</span>
                            <span x-show="loading">Cargando...</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Fila Superior: Tasas + Calculadora + Indicador -->
            <div x-show="stats.bcv && stats.binance" class="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">

                <!-- Tasas Actuales -->
                <div class="bg-white rounded-lg shadow-md p-2">
                    <div class="text-xs text-gray-500 mb-1 font-semibold">Tasas Actuales</div>
                    <div class="flex justify-between items-center">
                        <div class="text-center">
                            <div class="text-xs text-gray-500">BCV</div>
                            <div class="text-lg font-bold text-blue-600" x-text="formatRate(stats.bcv?.current)"></div>
                        </div>
                        <div class="text-xl text-gray-300">‚Üí</div>
                        <div class="text-center">
                            <div class="text-xs text-gray-500">Binance</div>
                            <div class="text-lg font-bold text-orange-600" x-text="formatRate(stats.binance?.current)"></div>
                        </div>
                    </div>
                </div>

                <!-- Calculadora USD BCV ‚Üí USD Binance -->
                <div class="bg-gradient-to-br from-green-50 to-emerald-50 rounded-lg shadow-md p-2">
                    <div class="text-xs text-gray-600 mb-1 font-semibold">üí± USD BCV ‚Üí USD Binance</div>
                    <div class="flex items-center gap-2 mb-2">
                        <input
                            type="number"
                            x-model="usdAmount"
                            @input="calculateConversion()"
                            placeholder="100"
                            class="w-24 px-2 py-1 border border-gray-300 rounded text-sm"
                        >
                        <span class="text-xs font-semibold text-gray-700">USD (BCV)</span>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500">Equivale a</div>
                        <div class="text-2xl font-bold text-orange-600" x-text="formatUsd(usdBinance)"></div>
                        <div class="text-xs text-gray-500">USD (Binance)</div>
                    </div>
                    <div class="mt-1 pt-1 border-t border-green-200 text-center">
                        <span class="text-xs text-gray-600">Diferencia:</span>
                        <span class="font-bold text-green-600 text-sm" x-text="formatUsd(usdDifference)"></span>
                    </div>
                </div>

                <!-- Indicador de Spread -->
                <div class="bg-gradient-to-br from-purple-50 to-pink-50 rounded-lg shadow-md p-2">
                    <div class="text-xs text-gray-600 mb-1 font-semibold">üìà Estado del Spread</div>
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="text-2xl font-bold text-purple-600" x-text="formatPercentage(stats.spreadPercent)"></div>
                            <div class="text-xs text-gray-500" x-text="formatRate(stats.spread)"></div>
                        </div>
                        <span
                            class="px-3 py-1 rounded-full text-xs font-semibold"
                            :class="{
                                'bg-green-500 text-white': getSpreadIndicator() === 'high',
                                'bg-yellow-500 text-white': getSpreadIndicator() === 'medium',
                                'bg-red-500 text-white': getSpreadIndicator() === 'low'
                            }"
                            x-text="getSpreadLabel()"
                        ></span>
                    </div>
                    <div class="border-t border-purple-200 pt-1">
                        <div class="grid grid-cols-4 gap-1 text-xs">
                            <div class="text-center">
                                <div class="text-red-600 font-semibold" x-text="stats.spreadStats ? formatPercentage(stats.spreadStats.min) : '-'"></div>
                                <div class="text-gray-500 text-[10px]">üî¥ Malo</div>
                            </div>
                            <div class="text-center">
                                <div class="text-gray-700 font-semibold" x-text="stats.spreadStats ? formatPercentage(stats.spreadStats.avg) : '-'"></div>
                                <div class="text-gray-500 text-[10px]">‚ö™ Promedio</div>
                            </div>
                            <div class="text-center">
                                <div class="text-yellow-600 font-semibold" x-text="stats.spreadStats ? formatPercentage(stats.spreadStats.p75) : '-'"></div>
                                <div class="text-gray-500 text-[10px]">üü° Bueno</div>
                            </div>
                            <div class="text-center">
                                <div class="text-green-600 font-semibold" x-text="stats.spreadStats ? formatPercentage(stats.spreadStats.max) : '-'"></div>
                                <div class="text-gray-500 text-[10px]">üü¢ Excelente</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chart Controls Info (Compacto) -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-2 mb-3">
                <div class="text-xs text-blue-800 text-center">
                    üñ±Ô∏è Zoom con rueda | üëÜ Arrastra para desplazar | üìç Doble clic para reset
                </div>
            </div>

            <!-- Chart -->
            <div class="bg-white rounded-lg shadow-md p-4 mb-3">
                <div x-show="loading" class="flex justify-center items-center" style="height: 350px;">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
                </div>

                <div x-show="!loading && error" class="flex justify-center items-center" style="height: 350px;">
                    <div class="text-red-600 text-center">
                        <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <p class="text-lg font-semibold" x-text="error"></p>
                    </div>
                </div>

                <div x-show="!loading && !error">
                    <div
                        id="ratesChart"
                        class="w-full"
                        style="height: 350px;"
                    ></div>
                </div>
            </div>

            <!-- Gr√°fico 2: Spread % Ampliado -->
            <div class="bg-white rounded-lg shadow-md p-4 mb-3">
                <h3 class="text-sm font-semibold text-purple-700 mb-2">üìä Spread Porcentual - Vista Ampliada</h3>

                <div x-show="loading" class="flex justify-center items-center" style="height: 300px;">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600"></div>
                </div>

                <div x-show="!loading && !error">
                    <div
                        id="spreadPercentChart"
                        class="w-full"
                        style="height: 300px;"
                    ></div>
                </div>
            </div>

            <!-- Footer info -->
            <div class="mt-3 text-center text-xs text-gray-500">
                <span x-text="startDate" class="font-semibold"></span> ‚Üí <span x-text="endDate" class="font-semibold"></span>
                | BCV: <span x-text="bcvDataPoints"></span> | Binance: <span x-text="binanceDataPoints"></span>
            </div>

        </div>
    </div>

    <script>
        function chartApp() {
            return {
                days: 30,
                endDate: new Date().toISOString().split('T')[0],
                startDate: '',
                loading: false,
                error: null,
                chart: null,
                bcvSeries: null,
                binanceSeries: null,
                spreadSeries: null,
                spreadChart: null,
                spreadChartSeries: null,
                stats: {
                    bcv: null,
                    binance: null,
                    spread: null,
                    spreadPercent: null,
                    spreadStats: null
                },
                bcvDataPoints: 0,
                binanceDataPoints: 0,
                usdAmount: 100,
                usdBinance: 0,
                usdDifference: 0,

                init() {
                    this.fetchData();
                },

                calculateConversion() {
                    if (!this.stats.bcv || !this.stats.binance || !this.usdAmount) {
                        this.usdBinance = 0;
                        this.usdDifference = 0;
                        return;
                    }

                    const usdBcv = parseFloat(this.usdAmount) || 0;
                    // USD BCV ‚Üí Bs (usando tasa BCV)
                    const bsTotal = usdBcv * this.stats.bcv.current;
                    // Bs ‚Üí USD Binance (usando tasa Binance)
                    this.usdBinance = bsTotal / this.stats.binance.current;
                    // Diferencia en USD
                    this.usdDifference = this.usdBinance - usdBcv;
                },

                async fetchData() {
                    this.loading = true;
                    this.error = null;

                    try {
                        const url = `/api/exchange-rates/bcv/?days=${this.days}&end_date=${this.endDate}`;
                        const response = await fetch(url);

                        if (!response.ok) {
                            throw new Error('Error al cargar los datos');
                        }

                        const data = await response.json();

                        this.startDate = data.start_date;
                        this.bcvDataPoints = data.bcv.length;
                        this.binanceDataPoints = data.binance_sell.length;

                        if (data.bcv.length === 0 && data.binance_sell.length === 0) {
                            this.error = 'No hay datos disponibles para este per√≠odo';
                            this.loading = false;
                            return;
                        }


                        this.calculateStats(data.bcv, data.binance_sell);
                        this.calculateConversion();
                        this.renderChart(data.bcv, data.binance_sell);

                    } catch (err) {
                        this.error = err.message;
                        console.error('Error:', err);
                    } finally {
                        this.loading = false;
                    }
                },

                calculateStats(bcvRates, binanceRates) {
                    // Stats BCV
                    if (bcvRates.length > 0) {
                        const bcvValues = bcvRates.map(r => r.rate);
                        this.stats.bcv = {
                            current: bcvValues[bcvValues.length - 1],
                            max: Math.max(...bcvValues),
                            min: Math.min(...bcvValues),
                            change: bcvValues[bcvValues.length - 1] - bcvValues[0]
                        };
                    }

                    // Stats Binance
                    if (binanceRates.length > 0) {
                        const binanceValues = binanceRates.map(r => r.rate);
                        this.stats.binance = {
                            current: binanceValues[binanceValues.length - 1],
                            max: Math.max(...binanceValues),
                            min: Math.min(...binanceValues),
                            change: binanceValues[binanceValues.length - 1] - binanceValues[0]
                        };
                    }

                    // Calcular spread actual
                    if (this.stats.bcv && this.stats.binance) {
                        this.stats.spread = this.stats.binance.current - this.stats.bcv.current;
                        this.stats.spreadPercent = (this.stats.spread / this.stats.binance.current) * 100;
                    }

                    // Calcular estad√≠sticas del spread hist√≥rico
                    if (bcvRates.length > 0 && binanceRates.length > 0) {
                        const bcvMap = new Map();
                        bcvRates.forEach(r => {
                            bcvMap.set(r.date, parseFloat(r.rate));
                        });

                        // Calcular spreads para todos los puntos de Binance
                        const spreadPercents = [];
                        const spreadBs = [];

                        binanceRates.forEach(r => {
                            const date = r.timestamp.split('T')[0];
                            const bcvRate = bcvMap.get(date);
                            const binanceRate = parseFloat(r.rate);

                            if (bcvRate && !isNaN(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                                const spreadPct = ((binanceRate - bcvRate) / binanceRate) * 100;
                                const spreadB = binanceRate - bcvRate;

                                if (!isNaN(spreadPct) && isFinite(spreadPct)) {
                                    spreadPercents.push(spreadPct);
                                    spreadBs.push(spreadB);
                                }
                            }
                        });

                        if (spreadPercents.length > 0) {
                            // Ordenar para calcular percentiles
                            const sortedPercents = [...spreadPercents].sort((a, b) => a - b);
                            const sortedBs = [...spreadBs].sort((a, b) => a - b);

                            const avg = spreadPercents.reduce((a, b) => a + b, 0) / spreadPercents.length;
                            const avgBs = spreadBs.reduce((a, b) => a + b, 0) / spreadBs.length;

                            // Calcular desviaci√≥n est√°ndar
                            const variance = spreadPercents.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / spreadPercents.length;
                            const stdDev = Math.sqrt(variance);

                            // Calcular percentiles
                            const p25 = sortedPercents[Math.floor(sortedPercents.length * 0.25)];
                            const p50 = sortedPercents[Math.floor(sortedPercents.length * 0.50)];
                            const p75 = sortedPercents[Math.floor(sortedPercents.length * 0.75)];

                            this.stats.spreadStats = {
                                avg: avg,
                                avgBs: avgBs,
                                max: Math.max(...spreadPercents),
                                min: Math.min(...spreadPercents),
                                maxBs: Math.max(...spreadBs),
                                minBs: Math.min(...spreadBs),
                                stdDev: stdDev,
                                p25: p25,
                                p50: p50,
                                p75: p75,
                                spreadPercents: spreadPercents,
                                spreadBs: spreadBs
                            };
                        }
                    }
                },

                fillBcvGaps(bcvRates, binanceRates) {
                    if (bcvRates.length === 0) return [];

                    // Si no hay datos de Binance, devolver BCV como est√° (con timestamps de medianoche)
                    if (binanceRates.length === 0) {
                        return bcvRates.map(r => ({
                            timestamp: r.date + 'T00:00:00Z',
                            rate: r.rate
                        }));
                    }

                    // Crear mapa de fechas BCV (solo fecha, sin hora)
                    const bcvMap = new Map();
                    bcvRates.forEach(r => {
                        const rate = parseFloat(r.rate);
                        if (!isNaN(rate) && isFinite(rate)) {
                            bcvMap.set(r.date, rate);
                        }
                    });

                    // Obtener todos los timestamps √∫nicos de Binance
                    const binanceTimestamps = binanceRates.map(r => ({
                        timestamp: r.timestamp,
                        date: r.timestamp.split('T')[0]
                    }));

                    // Para cada timestamp de Binance, asignar el valor de BCV de ese d√≠a
                    const filled = [];
                    let lastKnownValue = null;

                    binanceTimestamps.forEach(item => {
                        const bcvValue = bcvMap.get(item.date);

                        // Si hay valor para ese d√≠a, usarlo; si no, usar el √∫ltimo conocido
                        if (bcvValue !== undefined) {
                            lastKnownValue = bcvValue;
                        }

                        if (lastKnownValue !== null) {
                            filled.push({
                                timestamp: item.timestamp,
                                rate: lastKnownValue
                            });
                        }
                    });

                    return filled;
                },

                renderChart(bcvRates, binanceRates) {
                    const container = document.getElementById('ratesChart');

                    // Verificar que la biblioteca est√© disponible
                    if (typeof LightweightCharts === 'undefined') {
                        console.error('LightweightCharts no est√° disponible');
                        this.error = 'Error al cargar la biblioteca de gr√°ficos';
                        return;
                    }

                    // Rellenar huecos en BCV sincronizando con timestamps de Binance
                    const bcvFilled = this.fillBcvGaps(bcvRates, binanceRates);

                    // Remover chart anterior si existe
                    if (this.chart) {
                        this.chart.remove();
                        this.chart = null;
                    }

                    // Crear nuevo chart con dos escalas de precio
                    this.chart = LightweightCharts.createChart(container, {
                        width: container.clientWidth,
                        height: 350,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333',
                        },
                        grid: {
                            vertLines: { color: '#f0f0f0' },
                            horzLines: { color: '#f0f0f0' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#cccccc',
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.2,
                            },
                        },
                        leftPriceScale: {
                            visible: true,
                            borderColor: '#9333ea',
                            scaleMargins: {
                                top: 0.6,
                                bottom: 0.05,
                            },
                        },
                        timeScale: {
                            borderColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                        handleScroll: {
                            mouseWheel: true,
                            pressedMouseMove: true,
                        },
                        handleScale: {
                            axisPressedMouseMove: true,
                            mouseWheel: true,
                            pinch: true,
                        },
                    });

                    // Serie BCV (l√≠nea azul)
                    if (bcvFilled.length > 0) {
                        this.bcvSeries = this.chart.addLineSeries({
                            color: '#2563eb',
                            lineWidth: 2,
                            title: 'BCV (Oficial)',
                            priceFormat: {
                                type: 'price',
                                precision: 4,
                                minMove: 0.0001,
                            },
                        });

                        // Convertir datos a formato TradingView usando timestamps Unix
                        const bcvData = bcvFilled
                            .map(r => {
                                const timestamp = new Date(r.timestamp).getTime();
                                return {
                                    time: Math.floor(timestamp / 1000),
                                    value: parseFloat(r.rate)
                                };
                            })
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (bcvData.length > 0 && !bcvData.some(d => d.value === undefined)) {
                            this.bcvSeries.setData(bcvData);
                        }
                    }

                    // Serie Binance (l√≠nea naranja)
                    if (binanceRates.length > 0) {
                        this.binanceSeries = this.chart.addLineSeries({
                            color: '#f97316',
                            lineWidth: 2,
                            title: 'Binance P2P (Venta)',
                            priceFormat: {
                                type: 'price',
                                precision: 4,
                                minMove: 0.0001,
                            },
                        });

                        const binanceData = binanceRates
                            .map(r => {
                                const timestamp = new Date(r.timestamp).getTime();
                                return {
                                    time: Math.floor(timestamp / 1000),
                                    value: parseFloat(r.rate)
                                };
                            })
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (binanceData.length > 0 && !binanceData.some(d => d.value === undefined)) {
                            this.binanceSeries.setData(binanceData);
                        }
                    }

                    // Serie de Spread Porcentual (histograma en eje izquierdo)
                    if (bcvFilled.length > 0 && binanceRates.length > 0) {
                        // Crear mapa de timestamps BCV para b√∫squeda r√°pida (ahora sincronizado!)
                        const bcvMap = new Map();
                        bcvFilled.forEach(r => {
                            const rate = parseFloat(r.rate);
                            if (!isNaN(rate) && isFinite(rate)) {
                                bcvMap.set(r.timestamp, rate);
                            }
                        });

                        // Calcular spread porcentual para cada punto de Binance
                        const spreadData = [];
                        binanceRates.forEach(r => {
                            const timestamp = r.timestamp;
                            const binanceRate = parseFloat(r.rate);
                            const bcvRate = bcvMap.get(timestamp); // Ahora busca por timestamp exacto!

                            if (bcvRate && !isNaN(binanceRate) && isFinite(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                                const spreadPercent = ((binanceRate - bcvRate) / binanceRate) * 100;
                                const unixTime = Math.floor(new Date(timestamp).getTime() / 1000);

                                // Validar que todos los valores sean v√°lidos
                                if (!isNaN(spreadPercent) && isFinite(spreadPercent) && !isNaN(unixTime)) {
                                    // Color seg√∫n si el spread es positivo o negativo
                                    const color = spreadPercent >= 0 ? '#9333ea' : '#10b981';

                                    spreadData.push({
                                        time: unixTime,
                                        value: spreadPercent,
                                        color: color
                                    });
                                }
                            }
                        });

                        // Filtrar y ordenar datos del spread
                        const spreadDataFiltered = spreadData
                            .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                            .sort((a, b) => a.time - b.time);

                        if (spreadDataFiltered.length > 0 && !spreadDataFiltered.some(d => d.value === undefined)) {
                            this.spreadSeries = this.chart.addHistogramSeries({
                                color: '#9333ea',
                                title: 'Spread % (Binance vs BCV)',
                                priceScaleId: 'left',
                                priceFormat: {
                                    type: 'price',
                                    precision: 2,
                                    minMove: 0.01,
                                },
                            });

                            this.spreadSeries.setData(spreadDataFiltered);
                        }
                    }

                    // Configurar vista inicial: mostrar √∫ltimos 7 d√≠as
                    // Usar setTimeout para asegurar que el chart est√© completamente renderizado
                    setTimeout(() => {
                        if (!this.chart) return;

                        // Obtener el rango completo de datos
                        const timeScale = this.chart.timeScale();
                        const logicalRange = timeScale.getVisibleLogicalRange();

                        if (logicalRange) {
                            const totalBars = logicalRange.to;
                            const sevenDaysApprox = 7 * 24 * 4; // 7 d√≠as * 24 horas * 4 registros/hora (aprox)
                            const barsToShow = Math.min(sevenDaysApprox, totalBars);

                            // Mostrar solo las √∫ltimas barras (√∫ltimos 7 d√≠as)
                            timeScale.setVisibleLogicalRange({
                                from: totalBars - barsToShow,
                                to: totalBars
                            });
                        }
                    }, 100);

                    // Hacer responsive
                    new ResizeObserver(entries => {
                        if (entries.length === 0 || !this.chart) return;
                        const newWidth = entries[0].contentRect.width;
                        this.chart.applyOptions({ width: newWidth });
                    }).observe(container);

                    // Renderizar gr√°ficos adicionales
                    this.renderSpreadPercentChart(bcvFilled, binanceRates);
                },

                renderSpreadPercentChart(bcvFilled, binanceRates) {
                    const container = document.getElementById('spreadPercentChart');
                    if (!container || typeof LightweightCharts === 'undefined') return;

                    // Remover chart anterior si existe
                    if (this.spreadChart) {
                        this.spreadChart.remove();
                        this.spreadChart = null;
                    }

                    if (bcvFilled.length === 0 || binanceRates.length === 0) return;

                    // Crear mapa de BCV
                    const bcvMap = new Map();
                    bcvFilled.forEach(r => {
                        const rate = parseFloat(r.rate);
                        if (!isNaN(rate) && isFinite(rate)) {
                            bcvMap.set(r.timestamp, rate);
                        }
                    });

                    // Calcular spread porcentual
                    const spreadData = [];
                    binanceRates.forEach(r => {
                        const timestamp = r.timestamp;
                        const binanceRate = parseFloat(r.rate);
                        const bcvRate = bcvMap.get(timestamp);

                        if (bcvRate && !isNaN(binanceRate) && isFinite(binanceRate) && binanceRate > 0 && bcvRate > 0) {
                            const spreadPercent = ((binanceRate - bcvRate) / binanceRate) * 100;
                            const unixTime = Math.floor(new Date(timestamp).getTime() / 1000);

                            if (!isNaN(spreadPercent) && isFinite(spreadPercent) && !isNaN(unixTime)) {
                                // Color basado en umbral P75
                                let color = '#9333ea'; // p√∫rpura por defecto
                                if (this.stats.spreadStats) {
                                    if (spreadPercent >= this.stats.spreadStats.p75) {
                                        color = '#10b981'; // verde = excelente
                                    } else if (spreadPercent >= this.stats.spreadStats.avg) {
                                        color = '#f59e0b'; // amarillo = bueno
                                    } else {
                                        color = '#ef4444'; // rojo = bajo
                                    }
                                }

                                spreadData.push({
                                    time: unixTime,
                                    value: spreadPercent,
                                    color: color
                                });
                            }
                        }
                    });

                    const spreadDataFiltered = spreadData
                        .filter(d => d.time && !isNaN(d.time) && d.value !== undefined && !isNaN(d.value) && isFinite(d.value))
                        .sort((a, b) => a.time - b.time);

                    if (spreadDataFiltered.length === 0) return;

                    // Crear chart
                    this.spreadChart = LightweightCharts.createChart(container, {
                        width: container.clientWidth,
                        height: 300,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333',
                        },
                        grid: {
                            vertLines: { color: '#f0f0f0' },
                            horzLines: { color: '#f0f0f0' },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#cccccc',
                            autoScale: true,
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.2,
                            },
                        },
                        timeScale: {
                            borderColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                        handleScroll: {
                            mouseWheel: true,
                            pressedMouseMove: true,
                        },
                        handleScale: {
                            axisPressedMouseMove: true,
                            mouseWheel: true,
                            pinch: true,
                        },
                    });

                    // A√±adir serie de histograma
                    this.spreadChartSeries = this.spreadChart.addHistogramSeries({
                        color: '#9333ea',
                        priceFormat: {
                            type: 'price',
                            precision: 2,
                            minMove: 0.01,
                        },
                    });

                    this.spreadChartSeries.setData(spreadDataFiltered);

                    // A√±adir l√≠neas de referencia (umbrales)
                    if (this.stats.spreadStats) {
                        // L√≠nea promedio (amarilla)
                        const avgLine = this.spreadChart.addLineSeries({
                            color: '#f59e0b',
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Dashed,
                            title: 'Promedio',
                            priceLineVisible: false,
                            lastValueVisible: true,
                        });
                        avgLine.setData(spreadDataFiltered.map(d => ({ time: d.time, value: this.stats.spreadStats.avg })));

                        // L√≠nea P75 (verde)
                        const p75Line = this.spreadChart.addLineSeries({
                            color: '#10b981',
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Dashed,
                            title: 'P75 (Bueno)',
                            priceLineVisible: false,
                            lastValueVisible: true,
                        });
                        p75Line.setData(spreadDataFiltered.map(d => ({ time: d.time, value: this.stats.spreadStats.p75 })));
                    }

                    // L√≠nea invisible en 20% para forzar el eje Y a empezar desde 20%
                    const anchorLine = this.spreadChart.addLineSeries({
                        color: 'transparent',
                        lineWidth: 0,
                        priceLineVisible: false,
                        lastValueVisible: false,
                        crosshairMarkerVisible: false,
                    });
                    anchorLine.setData(spreadDataFiltered.map(d => ({ time: d.time, value: 20 })));

                    // Configurar vista inicial
                    setTimeout(() => {
                        if (!this.spreadChart) return;
                        const timeScale = this.spreadChart.timeScale();
                        const logicalRange = timeScale.getVisibleLogicalRange();

                        if (logicalRange) {
                            const totalBars = logicalRange.to;
                            const sevenDaysApprox = 7 * 24 * 4;
                            const barsToShow = Math.min(sevenDaysApprox, totalBars);

                            timeScale.setVisibleLogicalRange({
                                from: totalBars - barsToShow,
                                to: totalBars
                            });
                        }

                    }, 100);

                    // Hacer responsive
                    new ResizeObserver(entries => {
                        if (entries.length === 0 || !this.spreadChart) return;
                        const newWidth = entries[0].contentRect.width;
                        this.spreadChart.applyOptions({ width: newWidth });
                    }).observe(container);
                },

                formatDate(dateStr) {
                    const date = new Date(dateStr + 'T00:00:00');
                    return date.toLocaleDateString('es-VE', {
                        month: 'short',
                        day: 'numeric'
                    });
                },

                formatRate(rate) {
                    if (!rate) return '-';
                    return rate.toFixed(4) + ' Bs';
                },

                formatChange(change) {
                    if (!change) return '-';
                    const sign = change >= 0 ? '+' : '';
                    return sign + change.toFixed(4) + ' Bs';
                },

                formatPercentage(percent) {
                    if (!percent) return '-';
                    const sign = percent >= 0 ? '+' : '';
                    return sign + percent.toFixed(2) + '%';
                },

                getSpreadIndicator() {
                    if (!this.stats.spreadStats || !this.stats.spreadPercent) return 'low';

                    const current = this.stats.spreadPercent;
                    const avg = this.stats.spreadStats.avg;
                    const p75 = this.stats.spreadStats.p75;

                    if (current >= p75) return 'high';
                    if (current >= avg) return 'medium';
                    return 'low';
                },

                getSpreadLabel() {
                    const indicator = this.getSpreadIndicator();
                    if (indicator === 'high') return 'üü¢ EXCELENTE';
                    if (indicator === 'medium') return 'üü° BUENO';
                    return 'üî¥ BAJO';
                },

                formatBsShort(value) {
                    if (!value || isNaN(value)) return '-';
                    return value.toFixed(2) + ' Bs';
                },

                formatUsd(value) {
                    if (!value || isNaN(value)) return '-';
                    const sign = value >= 0 ? '' : '';
                    return sign + value.toFixed(2) + ' USD';
                }
            }
        }
    </script>
</body>
</html>
