"""
Views for database backup functionality
"""
import subprocess
import tempfile
import gzip
import os
from datetime import datetime
from django.http import HttpResponse, JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.core.management import call_command
from django.db import connection
from io import StringIO
from decouple import config
import MySQLdb


def generate_mysql_dump(db_name, db_user, db_password, db_host, db_port):
    """
    Genera un dump completo de la base de datos MySQL usando Python.
    Retorna un string con el dump SQL completo.
    """
    # Conectar a la base de datos
    conn = MySQLdb.connect(
        host=db_host,
        port=int(db_port),
        user=db_user,
        passwd=db_password,
        db=db_name
    )
    cursor = conn.cursor()

    dump_lines = []

    # Header del dump
    dump_lines.append("-- MySQL dump generated by Financial Helper")
    dump_lines.append(f"-- Host: {db_host}    Database: {db_name}")
    dump_lines.append(f"-- ------------------------------------------------------")
    dump_lines.append(f"-- Server version\t{conn.get_server_info()}")
    dump_lines.append("")
    dump_lines.append("SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT;")
    dump_lines.append("SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS;")
    dump_lines.append("SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION;")
    dump_lines.append("SET NAMES utf8mb4;")
    dump_lines.append("SET @OLD_TIME_ZONE=@@TIME_ZONE;")
    dump_lines.append("SET TIME_ZONE='+00:00';")
    dump_lines.append("SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;")
    dump_lines.append("SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;")
    dump_lines.append("SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO';")
    dump_lines.append("SET @OLD_AUTOCOMMIT=@@AUTOCOMMIT, AUTOCOMMIT=0;")
    dump_lines.append("")

    # Obtener lista de tablas
    cursor.execute("SHOW TABLES")
    tables = [row[0] for row in cursor.fetchall()]

    # Para cada tabla
    for table in tables:
        dump_lines.append(f"--")
        dump_lines.append(f"-- Table structure for table `{table}`")
        dump_lines.append(f"--")
        dump_lines.append("")
        dump_lines.append(f"DROP TABLE IF EXISTS `{table}`;")

        # Obtener CREATE TABLE
        cursor.execute(f"SHOW CREATE TABLE `{table}`")
        create_table = cursor.fetchone()[1]
        dump_lines.append(create_table + ";")
        dump_lines.append("")

        # Obtener datos
        dump_lines.append(f"--")
        dump_lines.append(f"-- Dumping data for table `{table}`")
        dump_lines.append(f"--")
        dump_lines.append("")
        dump_lines.append(f"LOCK TABLES `{table}` WRITE;")

        cursor.execute(f"SELECT * FROM `{table}`")
        rows = cursor.fetchall()

        if rows:
            # Obtener nombres de columnas
            cursor.execute(f"DESCRIBE `{table}`")
            columns = [col[0] for col in cursor.fetchall()]
            columns_str = ", ".join([f"`{col}`" for col in columns])

            # Insertar datos en lotes de 100 registros
            batch_size = 100
            for i in range(0, len(rows), batch_size):
                batch = rows[i:i+batch_size]
                values_list = []

                for row in batch:
                    values = []
                    for val in row:
                        if val is None:
                            values.append("NULL")
                        elif isinstance(val, (int, float)):
                            values.append(str(val))
                        elif isinstance(val, bytes):
                            # Para campos binarios
                            values.append(f"0x{val.hex()}")
                        else:
                            # Escapar comillas y backslashes
                            val_str = str(val).replace('\\', '\\\\').replace("'", "\\'")
                            values.append(f"'{val_str}'")
                    values_list.append(f"({', '.join(values)})")

                if values_list:
                    insert_stmt = f"INSERT INTO `{table}` ({columns_str}) VALUES\n"
                    insert_stmt += ",\n".join(values_list) + ";"
                    dump_lines.append(insert_stmt)

        dump_lines.append("UNLOCK TABLES;")
        dump_lines.append("")

    # Footer
    dump_lines.append("COMMIT;")
    dump_lines.append("")
    dump_lines.append("SET TIME_ZONE=@OLD_TIME_ZONE;")
    dump_lines.append("SET SQL_MODE=@OLD_SQL_MODE;")
    dump_lines.append("SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;")
    dump_lines.append("SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;")
    dump_lines.append("SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT;")
    dump_lines.append("SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS;")
    dump_lines.append("SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION;")
    dump_lines.append("SET AUTOCOMMIT=@OLD_AUTOCOMMIT;")
    dump_lines.append("")
    dump_lines.append("-- Dump completed")
    dump_lines.append("")

    cursor.close()
    conn.close()

    return "\n".join(dump_lines)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def download_database_backup(request):
    """
    Endpoint para descargar un backup comprimido de la base de datos MySQL.

    Requiere autenticación mediante token en el header Authorization:
    Authorization: Bearer <BACKUP_TOKEN>

    Retorna un archivo .sql.gz con el dump completo de la base de datos.
    """
    # Obtener el token de autorización del header
    auth_header = request.headers.get('Authorization', '')

    # Validar formato "Bearer <token>"
    if not auth_header.startswith('Bearer '):
        return JsonResponse({
            'error': 'Unauthorized',
            'message': 'Missing or invalid Authorization header. Format: Bearer <token>'
        }, status=401)

    # Extraer el token
    provided_token = auth_header[7:]  # Remover "Bearer "

    # Token hardcodeado para autenticación
    HARDCODED_TOKEN = 'financial-helper-backup-secret-2024'

    # Validar el token
    if provided_token != HARDCODED_TOKEN:
        return JsonResponse({
            'error': 'Unauthorized',
            'message': 'Invalid authorization token'
        }, status=401)

    try:
        # Obtener credenciales de la base de datos
        db_name = config('DB_NAME', default='financial_helper')
        db_user = config('DB_USER', default='django_user')
        db_password = config('DB_PASSWORD', default='django_password')
        db_host = config('DB_HOST', default='db')
        db_port = config('DB_PORT', default='3306')

        # Crear archivo temporal para el dump SQL
        with tempfile.NamedTemporaryFile(mode='w+b', suffix='.sql', delete=False) as temp_sql:
            temp_sql_path = temp_sql.name

        # Crear archivo temporal para el dump comprimido
        with tempfile.NamedTemporaryFile(mode='w+b', suffix='.sql.gz', delete=False) as temp_gz:
            temp_gz_path = temp_gz.name

        try:
            # Generar el dump SQL usando Python directamente
            # Esto funciona sin necesidad de mysqldump instalado
            sql_dump = generate_mysql_dump(db_name, db_user, db_password, db_host, db_port)

            # Guardar en archivo temporal
            with open(temp_sql_path, 'w', encoding='utf-8') as sql_file:
                sql_file.write(sql_dump)

            # Comprimir el archivo SQL con gzip
            with open(temp_sql_path, 'rb') as f_in:
                with gzip.open(temp_gz_path, 'wb', compresslevel=9) as f_out:
                    f_out.writelines(f_in)

            # Leer el archivo comprimido
            with open(temp_gz_path, 'rb') as f:
                compressed_data = f.read()

            # Generar nombre de archivo con timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'financial_helper_backup_{timestamp}.sql.gz'

            # Crear respuesta HTTP con el archivo
            response = HttpResponse(compressed_data, content_type='application/gzip')
            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            response['Content-Length'] = len(compressed_data)

            return response

        finally:
            # Limpiar archivos temporales
            try:
                if os.path.exists(temp_sql_path):
                    os.unlink(temp_sql_path)
                if os.path.exists(temp_gz_path):
                    os.unlink(temp_gz_path)
            except Exception as cleanup_error:
                # No fallar si no se pueden eliminar los temporales
                print(f"Warning: Could not clean up temporary files: {cleanup_error}")

    except subprocess.CalledProcessError as e:
        error_message = e.stderr.decode('utf-8') if e.stderr else str(e)
        return JsonResponse({
            'error': 'Database backup failed',
            'message': error_message
        }, status=500)

    except Exception as e:
        return JsonResponse({
            'error': 'Internal server error',
            'message': str(e)
        }, status=500)
